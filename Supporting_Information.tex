\section{Supporting Information}

\subsection{Notebook Workflow}
\label{sec:notebook}

FRETBursts has been developed with the goal of facilitating computational reproducibility
of the performed data analysis~\cite{Buckheit_1995}. For this reason,
the preferential way of using FRETBursts is by executing one of the tutorials
which are in the form of Jupyter notebooks~\cite{Shen_2014}.
Jupyter (formerly IPython) notebooks are web-based documents which contain both
code and rich text (including equations, hyperlinks, figures, etc...).
FRETBursts tutorials are notebooks which can be re-executed,
modified or used to process new data files with minimal modifications.
The ``notebook workflow''~\cite{Shen_2014} not only facilitates
the description of the analysis (by integrating the code in a rich document)
but also greatly enhance its reproducibility by storing an execution trail
that includes software versions, input files, parameters, commands and all
the analysis results (text, figures, tables, etc...).

The Jupyter Notebook environment streamlines FRETBursts execution (compared to
a traditional script and terminal based approach) and allows
FRETBursts to be used even without prior python knowledge.
The user only needs to get familiar with the
notebook graphical environment, in order to be able to navigate and run the notebooks.
A list of all FRETBursts notebooks can be found in the
\verb|FRETBursts_notebooks| repository on GitHub
(\href{https://github.com/tritemio/FRETBursts_notebooks}{link}).
Finally, we provide a service to run FRETBursts online,
without requiring any software installation 
(\href{https://github.com/tritemio/FRETBursts_notebooks#run-online}{link}).


\subsection{Development and Contributions}
\label{sec:dev}
Errors are an inevitable reality in any reasonably complex software~\cite{Soergel_2015}. It is
therefore critical to implement countermeasures to
minimize the probability of introducing bugs and their potential impact~\cite{Prli__2012, Wilson_2014}.
We strive to follow modern best-practices in software development which are summarized
below.

FRETBursts (and the entire python ecosystem it depends on) is open source
and the source code is fully available for any scientist to study,
review and modify.
The open source nature of FRETBursts and of the python ecosystem,
not only makes it a more transparent, reviewable platform
for scientific data analysis, but also allows
to leverage state-of-the-art online services as GitHub (\href{http://https://github.com}{link}) for hosting,
issues tracking and code reviews, TravisCI
(\href{https://travis-ci.org}{link}) for continuous integration
(i.e. automated test suite execution on multiple platforms after each commit)
and \href{https://readthedocs.org/}{ReadTheDocs.org} for automatic documentation building and hosting.
All these services would be extremely costly, if available \textit{tout court},
for a proprietary software or platform~\cite{Freeman_2015}.

We highly value source code readability, a property which can
reduce the number of bugs by facilitating understanding and verifying the code.
For this purpose, FRETBursts code-base is well commented (more that 35\%
of source code),
follows the PEP8 python code style rules (\href{https://www.python.org/dev/peps/pep-0008/}{link}),
and has docstrings in napoleon format (\href{http://sphinxcontrib-napoleon.readthedocs.org/}{link}).

Reference documentation is built with Sphinx (\href{http://sphinx-doc.org/}{sphinx-doc.org})
and all the API documents are automatically generated from docstrings.
On each commit, documentation is automatically built and deployed on
\href{https://readthedocs.org/}{ReadTheDocs.org}.

Unit tests cover most of the core algorithms, ensuring consistency and
minimizing the probability of introducing bugs.
The TravisCI (\href{http://travis-ci.org}{link}) continuous integration service,
executes the full test suite on each commit, timely reporting errors.
As a rule, whenever a bug is discovered, the  fix also includes a new test
to ensure that the same bug cannot happen in the future.
In addition to the unit tests, we include a regression-test notebook
(\href{https://github.com/tritemio/FRETBursts/blob/master/notebooks/dev/tests/FRETBursts%20-%20Regression%20tests.ipynb}{link})
to easily compares numerical results between two versions of FRETBursts.
Additionally, the tutorials themselves are executed before each release as
an additional test layer to ensure that no errors or regressions are introduced.

FRETBursts is openly developed using the GitHub platform.
The authors encourage users to use GitHub issues for questions, discussions
and bug reports, and to submit patches through GitHub pull requests.
Contributors of any level of expertise are welcome in the projects
and publicly acknowledged.
Contributions can be as simple as pointing out deficiencies in the
documentation but can also be bug reports or corrections to
the documentation or code. Users willing to implement
new features are encouraged to open an Issue on GitHub and to submit
a Pull Request. The open source nature of FRETBursts guarantees that
contributions will remain available to the entire single-molecule
community.

\subsection{Timestamps and Burst Data}
\label{sec:burststimes}

Beyond providing prepackaged functions for established methods,
FRETBursts also provides the infrastructure for exploring new analysis approaches.
Users can easily get timestamps (or selection masks) for any photon stream.
Core burst data (start and stop times, indexes
and derived quantities for each burst) are stored in \verb|Bursts| objects
(\href{http://fretbursts.readthedocs.org/en/latest/burstsearch.html}{link}).
This object provides a simple and well-tested interface (100 \% unit-test coverage)
to access and manipulate burst data. \verb|Bursts| are created from a sequence of start/stop
times and indexes, while all the other fields are automatically
computed. \verb|Bursts|'s methods allow to recompute indexes relative to a different photon
selection or recompute start and stop times relative to a new timestamps array.
Additional methods perform fusion of nearby bursts or combination of two set of bursts
(time intersection or union). This functionality is used for example to implement
the DCBS.
In conclusion, \verb|Bursts| efficiently implements all the common operations performed
with burst data, providing and easy-to-use interface and well tested algorithms.
Leveraging \verb|Bursts| methods, users can implement new types of analysis without
wasting time implementing (and debugging) standard manipulation routines.
Examples of working directly with timestamps, masks (i.e. photon selections) and
burst data are provided in one of the FRETBursts notebooks (\href{http://nbviewer.jupyter.org/github/tritemio/FRETBursts_notebooks/blob/master/notebooks/Example%20-%20Working%20with%20timestamps%20and%20bursts.ipynb}{link}).
Section~\ref{sec:bva} provides a complete example on using FRETBursts to implement 
custom burst analysis techniques.

\paragraph{Python details}
Timestamps are stored in the \verb|Data| attribute \verb|ph_times_m|, which is a list
or arrays, one array per excitation spot. In single-spot measurements the full
timestamps array is accessed as \verb|Data.ph_times_m[0]|. To get  timestamps
of arbitrary photon streams, users can call \verb|Data.get_ph_times|
(\href{http://fretbursts.readthedocs.org/en/latest/data_class.html?highlight=get_ph_times#fretbursts.burstlib.Data.get_ph_times}{link}).
Photon streams are selected from the full (all-photons) timestamps array using
boolean masks, which can be obtained calling \verb|Data.get_ph_mask|
(\href{http://fretbursts.readthedocs.org/en/latest/data_class.html?highlight=get_ph_mask#fretbursts.burstlib.Data.get_ph_mask}{link}).
All burst data (e.g. start-stop times and indexes, burst duration, etc.) are stored in
\verb|Bursts| objects. For uniformity, the bursts start-stop
indexes are always referring to the all-photons timestamps array,
regardless of the photon stream used for burst search.
\verb|Bursts| objects
internally store only start and stop times and indexes.
The other \verb|Bursts| attributes (duration, photon counts, etc.) are computed on-the-fly
when requested (using class properties), thus minimizing the object state.
\verb|Bursts| support iteration
with performances similar to iterating through rows of 2D row-major numpy arrays.
